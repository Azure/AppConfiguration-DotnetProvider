diff --git a/examples/ConsoleApplication/Program.cs b/examples/ConsoleApplication/Program.cs
index a75065d..1167ab7 100644
--- a/examples/ConsoleApplication/Program.cs
+++ b/examples/ConsoleApplication/Program.cs
@@ -1,8 +1,12 @@
 ﻿namespace Microsoft.Extensions.Configuration.AzureAppConfiguration.Examples.ConsoleApplication
 {
+    using Microsoft.Azure.KeyVault;
+    using Microsoft.Azure.KeyVault.Models;
     using Microsoft.Extensions.Configuration;
     using Microsoft.Extensions.Configuration.AzureAppConfiguration;
+    using Microsoft.IdentityModel.Clients.ActiveDirectory;
     using System;
+    using System.Collections.Generic;
     using System.Text;
     using System.Threading;
     using System.Threading.Tasks;
@@ -11,9 +15,33 @@
     {
         static IConfiguration Configuration { get; set; }
 
+
+       
+
         static void Main(string[] args)
         {
-            Configure();
+
+
+
+            ///Version 1
+            /////////////////////////////////////////////////////////////
+            var builder = new ConfigurationBuilder(); //new config builder
+
+            builder.AddAzureAppConfiguration(Environment.GetEnvironmentVariable("ConnectionString")); //get the connecting string
+
+            IConfigurationRoot config = builder.Build(); //call the build method in config builder
+
+            string value = config[".appconfig.keyvault/TheTrialSecret"];
+            Console.WriteLine(value);
+
+            /*AzureKeyVaultKeyValueAdapter azureKeyVaultKeyValueAdapter = new AzureKeyVaultKeyValueAdapter();
+            azureKeyVaultKeyValueAdapter.GetSecretFromKeyVault(value);*/
+            /////////////////////////////////////////////////////////////
+
+
+            ///version 0
+            /////////////////////////////////////////////////////////////
+           /* Configure();
 
             var cts = new CancellationTokenSource();
 
@@ -23,9 +51,13 @@
             // Finish on key press
             Console.ReadKey();
 
-            cts.Cancel();
+            cts.Cancel();*/
+            /////////////////////////////////////////////////////////////
         }
 
+        /// version 0
+        /////////////////////////////////////////////////////////////
+
         private static void Configure()
         {
             var builder = new ConfigurationBuilder();
@@ -47,7 +79,8 @@
             //
             // Augment the configuration builder with Azure App Configuration
             // Pull the connection string from an environment variable
-            builder.AddAzureAppConfiguration(o => {
+            builder.AddAzureAppConfiguration(o =>
+            {
 
                 o.Connect(configuration["connection_string"])
                  //
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationOptions.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationOptions.cs
index 3cd8a63..59816dd 100644
--- a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationOptions.cs
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationOptions.cs
@@ -2,6 +2,7 @@
 {
     using Microsoft.Azure.AppConfiguration.Azconfig;
     using Microsoft.Azure.AppConfiguration.ManagedIdentityConnector;
+    using Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureKeyVault;
     using Microsoft.Extensions.Configuration.AzureAppConfiguration.FeatureManagement;
     using Microsoft.Extensions.Configuration.AzureAppConfiguration.Models;
     using System;
@@ -17,7 +18,7 @@
 
         private Dictionary<string, KeyValueWatcher> _changeWatchers = new Dictionary<string, KeyValueWatcher>();
         private List<KeyValueWatcher> _multiKeyWatchers = new List<KeyValueWatcher>();
-        private List<IKeyValueAdapter> _adapters = new List<IKeyValueAdapter>();
+        private List<IKeyValueAdapter> _adapters = new List<IKeyValueAdapter>() { new AzureKeyVaultKeyValueAdapter() };
         private List<KeyValueSelector> _kvSelectors = new List<KeyValueSelector>();
         private SortedSet<string> _keyPrefixes = new SortedSet<string>(Comparer<string>.Create((k1, k2) => -string.Compare(k1, k2, StringComparison.InvariantCultureIgnoreCase)));
 
@@ -201,6 +202,7 @@
             return this;
         }
 
+       
         /// <summary>
         /// Use an offline file cache to store Azure App Configuration data or retrieve previously stored data during offline periods.
         /// </summary>
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationProvider.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationProvider.cs
index 8922ea5..dfda9c6 100644
--- a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationProvider.cs
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureAppConfigurationProvider.cs
@@ -68,9 +68,9 @@
             }
         }
 
-        public override async void Load()
+        public override void Load()
         {
-            LoadAll();
+            LoadAll().ConfigureAwait(false).GetAwaiter().GetResult();
 
             //
             // Mark all settings have loaded at startup.
@@ -79,7 +79,7 @@
             ObserveKeyValues();
         }
 
-        private void LoadAll()
+        private async Task LoadAll()
         {
              IDictionary<string, IKeyValue> data = new Dictionary<string, IKeyValue>(StringComparer.OrdinalIgnoreCase);
 
@@ -124,7 +124,7 @@
                     };
 
                     ConfigureRequestTracingOptions(queryKeyValueCollectionOptions);
-                    _client.GetKeyValues(queryKeyValueCollectionOptions).ForEach(kv => { data[kv.Key] = kv; });
+                    _client.GetKeyValues(queryKeyValueCollectionOptions).ForEach(kv => data[kv.Key] = kv);
                 }
             }
             catch (Exception exception) when (exception.InnerException is HttpRequestException ||
@@ -136,7 +136,7 @@
                     data = JsonConvert.DeserializeObject<IDictionary<string, IKeyValue>>(_options.OfflineCache.Import(_options), new KeyValueConverter());
                     if (data != null)
                     {
-                        SetData(data);
+                        await SetData(data);
                         return;
                     }
                 }
@@ -149,7 +149,7 @@
                 return;
             }
 
-            SetData(data);
+            await SetData(data);
 
             if (_options.OfflineCache != null)
             {
@@ -180,17 +180,17 @@
 
                 IObservable<KeyValueChange> observable = _client.Observe(watchedKv, changeWatcher.PollInterval, Scheduler.Default, _requestTracingEnabled);
 
-                _subscriptions.Add(observable.Subscribe((observedChange) =>
+                _subscriptions.Add(observable.Subscribe(async (observedChange) =>
                 {
                     ProcessChanges(Enumerable.Repeat(observedChange, 1));
 
                     if (changeWatcher.ReloadAll)
                     {
-                        LoadAll();
+                       await LoadAll();
                     }
                     else
                     {
-                        SetData(_settings);
+                        await SetData(_settings);
                     }
                 }));
             }
@@ -213,16 +213,16 @@
                     existing,
                     _requestTracingEnabled);
 
-                _subscriptions.Add(observable.Subscribe((observedChanges) =>
+                _subscriptions.Add(observable.Subscribe(async (observedChanges) =>
                 {
                     ProcessChanges(observedChanges);
 
-                    SetData(_settings);
+                    await SetData(_settings);
                 }));
             }
         }
 
-        private void SetData(IDictionary<string, IKeyValue> data)
+        private async Task SetData(IDictionary<string, IKeyValue> data)
         {
             //
             // Update cache of settings
@@ -235,7 +235,7 @@
 
             foreach (KeyValuePair<string, IKeyValue> kvp in data)
             {
-                foreach (KeyValuePair<string, string> kv in ProcessAdapters(kvp.Value))
+                foreach (KeyValuePair<string, string> kv in await ProcessAdapters(kvp.Value))
                 {
                     string key = kv.Key;
                     foreach (string prefix in _options.KeyPrefixes)
@@ -258,13 +258,13 @@
             OnReload();
         }
         
-        private IEnumerable<KeyValuePair<string, string>> ProcessAdapters(IKeyValue keyValue)
+        private async Task<IEnumerable<KeyValuePair<string, string>>> ProcessAdapters(IKeyValue keyValue)
         {
             List<KeyValuePair<string, string>> keyValues = null;
 
             foreach (IKeyValueAdapter adapter in _options.Adapters)
             {
-                IEnumerable<KeyValuePair<string, string>> kvs = adapter.GetKeyValues(keyValue);
+                IEnumerable<KeyValuePair<string, string>> kvs = await adapter.GetKeyValues(keyValue);
 
                 if (kvs != null)
                 {
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/AzureKeyVaultKeyValueAdapter.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/AzureKeyVaultKeyValueAdapter.cs
new file mode 100644
index 0000000..e1c0dce
--- /dev/null
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/AzureKeyVaultKeyValueAdapter.cs
@@ -0,0 +1,81 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using Microsoft.Azure.AppConfiguration.Azconfig;
+using Microsoft.Azure.KeyVault;
+using Microsoft.Azure.KeyVault.Models;
+using Microsoft.Azure.Services.AppAuthentication;
+using Newtonsoft.Json;
+
+namespace Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureKeyVault
+{
+    internal class AzureKeyVaultKeyValueAdapter : IKeyValueAdapter
+    {
+        public AzureKeyVaultKeyValueAdapter()
+        {
+
+        }
+
+        private static readonly JsonSerializerSettings s_SerializationSettings = new JsonSerializerSettings { DateParseHandling = DateParseHandling.None };
+        private IKeyVaultClient _keyVaultClient;
+
+        /// <summary> Uses the managed identity to retrieve the actual value </summary>
+        /// <param KeyValue ="IKeyValue">  inputs the IKeyValue </param>
+        /// returns the keyname and actual value
+        public async Task<IEnumerable<KeyValuePair<string, string>>> GetKeyValues(IKeyValue keyValue)
+        {
+            string contentType = keyValue?.ContentType?.Split(';')[0].Trim();
+
+            //Checking if the content type is our type (If not we return null)
+            if (!string.Equals(contentType, KeyVaultConstants.ContentType))
+            {
+                return null;
+            }
+
+            KeyVaultSecretReference secretRef = JsonConvert.DeserializeObject<KeyVaultSecretReference>(keyValue.Value, s_SerializationSettings);
+
+            //Get secret from KeyVault
+            string secret = await GetSecretFromKeyVault(secretRef.Uri);
+
+            var keyValues = new List<KeyValuePair<string, string>>();
+
+            // add the key and it's value in the keyvaluePair
+            keyValues.Add(new KeyValuePair<string, string>(keyValue.Key, secret));
+
+            return keyValues;
+        }
+
+        /// <summary>
+        ///  Uses the managed identity to retrieve the actual value
+        /// </summary>
+        /// <param SecretUri ="s">  inputs the reference(uri) of the key </param>
+        /// Returns actual value
+        internal async Task<string> GetSecretFromKeyVault(string secretUri, Func<Task<SecretBundle>> f = null)
+        {
+            if (f == null)
+            { 
+                if (_keyVaultClient == null)
+                {
+                    //Use Managed identity
+                    var azureServiceTokenProvider = new AzureServiceTokenProvider();
+
+                    _keyVaultClient =
+                    new KeyVaultClient(
+                        new KeyVaultClient.AuthenticationCallback(azureServiceTokenProvider.KeyVaultTokenCallback));
+                }
+
+                f = () => _keyVaultClient.GetSecretAsync(secretUri);
+            }
+
+            SecretBundle secret = await GetSecret(f);
+
+            return secret?.Value;
+        }
+
+        private async Task<SecretBundle> GetSecret(Func<Task<SecretBundle>> f)
+        {
+                return await f();
+        }
+    }
+}
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/KeyVaultConstants.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/KeyVaultConstants.cs
new file mode 100644
index 0000000..70e222b
--- /dev/null
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/KeyVaultConstants.cs
@@ -0,0 +1,7 @@
+﻿namespace Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureKeyVault
+{
+    internal class KeyVaultConstants
+    {
+        public const string ContentType = "application/vnd.microsoft.appconfig.keyvault.secretref+json";
+    }
+}
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/KeyVaultSecretReference.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/KeyVaultSecretReference.cs
new file mode 100644
index 0000000..33fb10d
--- /dev/null
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/AzureKeyVaultReference/KeyVaultSecretReference.cs
@@ -0,0 +1,11 @@
+﻿using Newtonsoft.Json;
+
+namespace Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureKeyVault
+{
+    [JsonObject(MemberSerialization.OptIn)]
+    internal class KeyVaultSecretReference
+    {
+        [JsonProperty("uri")]
+        public string Uri { get; set; }
+    }
+}
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/FeatureManagement/FeatureManagementKeyValueAdapter.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/FeatureManagement/FeatureManagementKeyValueAdapter.cs
index 0b12a3e..0150024 100644
--- a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/FeatureManagement/FeatureManagementKeyValueAdapter.cs
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/FeatureManagement/FeatureManagementKeyValueAdapter.cs
@@ -1,5 +1,7 @@
-﻿using System.Collections.Generic;
+﻿using System;
+using System.Collections.Generic;
 using System.Linq;
+using System.Threading.Tasks;
 using Microsoft.Azure.AppConfiguration.Azconfig;
 using Newtonsoft.Json;
 
@@ -8,20 +10,29 @@ namespace Microsoft.Extensions.Configuration.AzureAppConfiguration.FeatureManage
     internal class FeatureManagementKeyValueAdapter : IKeyValueAdapter
     {
         private static readonly JsonSerializerSettings s_SerializationSettings = new JsonSerializerSettings { DateParseHandling = DateParseHandling.None };
+        private static readonly Task<IEnumerable<KeyValuePair<string, string>>> NullResult = Task.FromResult<IEnumerable<KeyValuePair<string, string>>>(null);
+        private FeatureFlag featureFlag;
 
-        public IEnumerable<KeyValuePair<string, string>> GetKeyValues(IKeyValue keyValue)
+        public Task<IEnumerable<KeyValuePair<string, string>>> GetKeyValues(IKeyValue keyValue)
         {
             string contentType = keyValue?.ContentType?.Split(';')[0].Trim();
 
             if (!string.Equals(contentType, FeatureManagementConstants.ContentType) ||
                 !keyValue.Key.StartsWith(FeatureManagementConstants.FeatureFlagMarker))
             {
-                return null;
+                return NullResult;
             }
 
-            //
-            // TODO error handling
-            FeatureFlag featureFlag = JsonConvert.DeserializeObject<FeatureFlag>(keyValue.Value, s_SerializationSettings);
+            try
+            {
+                featureFlag = JsonConvert.DeserializeObject<FeatureFlag>(keyValue.Value, s_SerializationSettings);
+
+            }
+            catch (NullReferenceException e)
+            {
+
+                Console.WriteLine("The FeatureFlag is Empty", e.Message);
+            }
 
             var keyValues = new List<KeyValuePair<string, string>>();
 
@@ -59,7 +70,9 @@ namespace Microsoft.Extensions.Configuration.AzureAppConfiguration.FeatureManage
                 keyValues.Add(new KeyValuePair<string, string>($"{FeatureManagementConstants.SectionName}:{featureFlag.Id}", false.ToString()));
             }
 
-            return keyValues;
+            return Task.FromResult<IEnumerable<KeyValuePair<string, string>>>(keyValues);
         }
+
+
     }
 }
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/IKeyValueAdapter.cs b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/IKeyValueAdapter.cs
index 8cbd38b..0d80574 100644
--- a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/IKeyValueAdapter.cs
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/IKeyValueAdapter.cs
@@ -1,10 +1,11 @@
 ﻿using System.Collections.Generic;
+using System.Threading.Tasks;
 using Microsoft.Azure.AppConfiguration.Azconfig;
 
 namespace Microsoft.Extensions.Configuration.AzureAppConfiguration
 {
     internal interface IKeyValueAdapter
     {
-        IEnumerable<KeyValuePair<string, string>> GetKeyValues(IKeyValue keyValue);
+        Task<IEnumerable<KeyValuePair<string, string>>> GetKeyValues(IKeyValue keyValue);
     }
 }
diff --git a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/Microsoft.Extensions.Configuration.AzureAppConfiguration.csproj b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/Microsoft.Extensions.Configuration.AzureAppConfiguration.csproj
index b282259..75df7ae 100644
--- a/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/Microsoft.Extensions.Configuration.AzureAppConfiguration.csproj
+++ b/src/Microsoft.Extensions.Configuration.AzureAppConfiguration/Microsoft.Extensions.Configuration.AzureAppConfiguration.csproj
@@ -10,10 +10,15 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.Azure.KeyVault" Version="3.0.3" />
+    <PackageReference Include="Microsoft.Azure.Management.KeyVault" Version="2.4.3" />
     <PackageReference Include="Microsoft.Extensions.Configuration" Version="$(MicrosoftExtensionsConfigurationVersion)" />
+    <PackageReference Include="Microsoft.IdentityModel.Clients.ActiveDirectory" Version="5.1.0" />
+    <PackageReference Include="Microsoft.Rest.ClientRuntime.Azure" Version="3.3.19" />
     <PackageReference Include="Newtonsoft.Json" Version="$(NewtonsoftJsonVersion)" />
     <PackageReference Include="Microsoft.Azure.AppConfiguration.AzconfigClient" Version="$(MicrosoftAzconfigClientVersion)" />
     <PackageReference Include="Microsoft.Azure.AppConfiguration.ManagedIdentityConnector" Version="$(MicrosoftAzconfigManagedIdentityConnectorVersion)" />
+    <PackageReference Include="System.Configuration.ConfigurationManager" Version="4.5.0" />
     <PackageReference Include="System.Interactive.Async" Version="$(SystemInteractiveAsyncVersion)" />
     <PackageReference Include="System.Reactive.Linq" Version="$(SystemReactiveLinqVersion)" />
     <PackageReference Include="Microsoft.AspNetCore.Http.Extensions" Version="$(MicrosoftAspNetCoreHttpExtensionsVersion)" />
diff --git a/tests/Tests.AzureAppConfiguration/CallbackMessageHandler.cs b/tests/Tests.AzureAppConfiguration/CallbackMessageHandler.cs
index 1d2da02..327bb0f 100644
--- a/tests/Tests.AzureAppConfiguration/CallbackMessageHandler.cs
+++ b/tests/Tests.AzureAppConfiguration/CallbackMessageHandler.cs
@@ -14,9 +14,6 @@ namespace Tests.AzureAppConfiguration
             _handler = handler;
         }
 
-        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
-        {
-            return Task.FromResult(_handler(request));
-        }
+        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) => Task.FromResult(_handler(request));
     }
 }
diff --git a/tests/Tests.AzureAppConfiguration/KeyVaultReferenceTests.cs b/tests/Tests.AzureAppConfiguration/KeyVaultReferenceTests.cs
new file mode 100644
index 0000000..c7f97b3
--- /dev/null
+++ b/tests/Tests.AzureAppConfiguration/KeyVaultReferenceTests.cs
@@ -0,0 +1,60 @@
+﻿using Microsoft.Azure.AppConfiguration.Azconfig;
+using Microsoft.Azure.KeyVault;
+using Microsoft.Azure.KeyVault.Models;
+using Microsoft.Extensions.Configuration;
+using Microsoft.Extensions.Configuration.AzureAppConfiguration;
+using Microsoft.Extensions.Configuration.AzureAppConfiguration.AzureKeyVault;
+using Moq;
+using Newtonsoft.Json;
+using System;
+using System.Collections.Generic;
+using System.Net;
+using System.Net.Http;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+using Xunit;
+
+namespace Tests.AzureAppConfiguration
+{
+    public class KeyVaultReferenceTests
+    {
+        private KeyValue _kv = new KeyValue("mySecret")
+        {
+            Value = @"
+                    {
+                        ""uri"":""https://keyvault-theclassics.vault.azure.net/TheTrialSecret""
+                    }
+                   ",
+            ETag = "c3c231fd-39a0-4cb6-3237-4614474b92c1",
+            ContentType = KeyVaultConstants.ContentType + "; charset=utf-8"
+        };
+
+        //Check successfull result for GetSecretFromKeyVault method
+        [Fact]
+        public async Task GetSecretFromKeyVault_Success()
+        {
+            var azureKeyVaultKeyValueAdapter = new AzureKeyVaultKeyValueAdapter();
+
+            var builder = new ConfigurationBuilder();
+            var config = builder.Build();
+            //KeyVaultSecretReference secretRef = JsonConvert.DeserializeObject<KeyVaultSecretReference>(keyValue.Value, s_SerializationSettings);
+
+            string secretUri = ".appconfig.keyvault/TheTrialSecret";
+            // string expected = await azureKeyVaultKeyValueAdapter.GetSecretFromKeyVault(secretRef.Uri);
+            var expected = await azureKeyVaultKeyValueAdapter.GetSecretFromKeyVault(secretUri, async () => await Task.Run(() => new SecretBundle() { Value = "newVersion" } ));
+            var actual = "newVersion";
+            Assert.Equal(actual, expected);
+        }
+
+        
+    }
+
+    public static class MockedKeyVaultClient
+    {
+        public static Task<SecretBundle> GetSecretAsync(this KeyVaultClient client, string secretIdentifier)
+        {
+            return Task.FromResult(new SecretBundle() { Value = "newVersion" });
+        }
+    }
+}
diff --git a/tests/Tests.AzureAppConfiguration/MockedKeyVault.cs b/tests/Tests.AzureAppConfiguration/MockedKeyVault.cs
new file mode 100644
index 0000000..ed67818
--- /dev/null
+++ b/tests/Tests.AzureAppConfiguration/MockedKeyVault.cs
@@ -0,0 +1,119 @@
+﻿using Microsoft.AspNetCore.Http;
+using Microsoft.Azure.AppConfiguration.Azconfig;
+using Newtonsoft.Json;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Net;
+using System.Net.Http;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Tests.AzureAppConfiguration
+{
+    class MockedKeyVault : HttpMessageHandler
+    {
+        private IKeyValue _kv;
+        private readonly IEnumerable<IKeyValue> _kvCollection;
+        private int _getKvCounter = 0;
+        private int _getKvsCounter = 0;
+        private const int _createNewKvTrigger = 1; 
+
+        public MockedKeyVault(IKeyValue kv, IEnumerable<IKeyValue>  kvCollection)
+        {
+            _kv = kv ?? throw new ArgumentException(nameof(kv));
+            _kvCollection = kvCollection ?? throw new ArgumentException(nameof(kvCollection));
+        }
+
+        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
+        {
+            HttpMethod method = request.Method;
+            if (request.Method == HttpMethod.Get)
+            {
+                if (request.RequestUri.AbsolutePath.StartsWith($"/kv/{_kv.Key}"))
+                {
+                    return GetKeyValue(request);
+                }
+                else if (request.RequestUri.AbsolutePath.StartsWith($"/kv"))
+                {
+                    return GetKeyValues(request);
+                }
+                else if (request.RequestUri.AbsolutePath.Contains($"theclassics"))
+                {
+                    return GetSecretBundle(request);
+                }
+            }
+            return Task.FromResult(new HttpResponseMessage());
+        }
+
+        private Task<HttpResponseMessage> GetKeyValue(HttpRequestMessage request)
+        {
+            // use counter to switch retrieved key value
+            // used in observe key tests
+            if (_getKvCounter >= _createNewKvTrigger)
+            {
+                _kv = new KeyValue(_kv.Key)
+                {
+                    ContentType = _kv.ContentType,
+                    Label = _kv.Label,
+                    Value = "newValue",
+                };
+            }
+            HttpResponseMessage response = new HttpResponseMessage();
+
+            response.StatusCode = HttpStatusCode.OK;
+            string json = JsonConvert.SerializeObject(_kv);
+            response.Content = new StringContent(json, Encoding.UTF8, "application/json");
+            _getKvCounter++;
+
+            return Task.FromResult(response);
+        }
+
+        private Task<HttpResponseMessage> GetKeyValues(HttpRequestMessage request)
+        {
+
+            HttpResponseMessage response = new HttpResponseMessage
+            {
+                StatusCode = HttpStatusCode.OK
+            };
+
+            IEnumerable<IKeyValue> keyvalues = _kvCollection;
+            if (_getKvCounter >= _createNewKvTrigger)
+            {
+                keyvalues = _kvCollection.Select(x => new KeyValue(x.Key)
+                {
+                    Value = "newValue",
+                    Label = x.Label,
+                    ContentType = x.ContentType,
+                    Tags = x.Tags
+                });
+            }
+
+            string json = JsonConvert.SerializeObject(new { items = keyvalues });
+
+            response.Content = new StringContent(json, Encoding.UTF8, "application/json");
+            _getKvsCounter++;
+            return Task.FromResult(response);
+        }
+
+        private Task<HttpResponseMessage> GetSecretBundle(HttpRequestMessage request)
+        {
+            HttpResponseMessage response = new HttpResponseMessage
+            {
+                StatusCode = HttpStatusCode.OK
+            };
+
+            IEnumerable<Microsoft.Azure.KeyVault.Models.SecretBundle> secretBundles = new List<Microsoft.Azure.KeyVault.Models.SecretBundle>()
+            {
+                new Microsoft.Azure.KeyVault.Models.SecretBundle() { Value = "newVersion" }
+            };
+
+            string json = JsonConvert.SerializeObject(new { items = secretBundles });
+
+            response.Content = new StringContent(json, Encoding.UTF8, "application/json");
+            _getKvsCounter++;
+            return Task.FromResult(response);
+        }
+    }
+}
\ No newline at end of file
diff --git a/tests/Tests.AzureAppConfiguration/TestHelper.cs b/tests/Tests.AzureAppConfiguration/TestHelper.cs
index d5e09ee..27e0a8b 100644
--- a/tests/Tests.AzureAppConfiguration/TestHelper.cs
+++ b/tests/Tests.AzureAppConfiguration/TestHelper.cs
@@ -9,7 +9,8 @@ namespace Tests.AzureAppConfiguration
         {
             byte[] toEncodeAsBytes = Encoding.ASCII.GetBytes("secret");
             string returnValue = Convert.ToBase64String(toEncodeAsBytes);
-            return $"Endpoint=https://xxxxx;Id=b1d9b31;Secret={returnValue}";
+            //return $"Endpoint=https://xxxxx;Id=b1d9b31;Secret={returnValue}";
+            return $"Endpoint=https://t-sebyusecondresource.azconfig.io;Id=2-l4-s0:OWhCnARLzy2wGn1/+nEz;Secret={returnValue}";
         }
     }
 }
diff --git a/tests/Tests.AzureAppConfiguration/Tests.cs b/tests/Tests.AzureAppConfiguration/Tests.cs
index 94f0cb0..5a6d0fd 100644
--- a/tests/Tests.AzureAppConfiguration/Tests.cs
+++ b/tests/Tests.AzureAppConfiguration/Tests.cs
@@ -293,7 +293,7 @@ namespace Tests.AzureAppConfiguration
                     Client = testClient
                 }.Use("*", null));
 
-                var config = builder.Build();
+                IConfigurationRoot config = builder.Build();
 
                 Assert.NotNull(correlationContext);
                 Assert.Contains(Enum.GetName(typeof(HostType), HostType.AzureFunction), correlationContext, StringComparison.InvariantCultureIgnoreCase);
